176,113 tech salaries visualized â€“ a dataviz dashboard
======================================================

https://github.com/Swizec/h1b-software-salaries/tree/modern-code

Show a Preloader
----------------

import bootstrap css in index.js
// src/index.js
import React from "react"
import ReactDOM from "react-dom"
import App from "./App"
// Insert the line(s) between here...
import "bootstrap/dist/css/bootstrap.css"
// ...and here.
ReactDOM.render(<App />, document.getElementById('root'))

Another benefit of Webpack
- importing stylesheets turn into style tags with CSS in their body in runtime

index.js
- load App and React
- load styles
- Use ReactDOM to render <App /> into the DOM


Load and Parse your data
------------------------
load data async using d3 csv parse script 

App.js
import d3, lodash (utility)
loadAllData from DataHandling
- keep code organize and clean
- we will create this file

// defining whats in your component state in advance makes your code easier to read
// people know what to expect
useState
- medianIncomes 
- countyNames

// useEffect to run when React first mounts the component
loadAllData((data) => {
  // get techSalaries, medianIncomes, countyNames
  setTechsalaries
  setMedianIncomes
  setCountyNames
})
- when loadAllData runs, it will fetch data, parse data and update state
- tie data loading to component mounts cuz it means you arent making requests you'll never use
- use state setters in the cb
- this updates Apps state and triggers a re-render -> updates our entire viz via props

h1
- Loaded {techSalaries.length} salaries
- render this message to show our data finished loading

D3 v5 
- updated its data loading methods to use promises instead of callbacks
d3.csv('filename').then(data => ...)
- the promise resolves your data or throws an error

loadAllData = async () => {
  const datasets = await Promise.all([
    d3.json('data/us.json'),
    d3.csv('data/....csv', cleanCounty),
    d3.csv('data/....csv', cleanIncome),
    ...
    d3.tsv('data/us-state-names.tsv', cleanUSStateName)
  ])
}
- d3 fetches the data, then on the promise return, it accepts a callback
- in this callback, well pass in our util method to clean up the data returned

D3 supporsts formats like json, csv, tsv, text, and xml out of the box

tie the data together
// DataHandling.js
async load the data
get the data
1 prep the App
- async loadData from DataHandling.js
2 prep data parsing functions
- data cleaning functions
3 load the dataset
- async loadAllData
- pass in cleaning functions as callbacks
4 tie all dataset together
- use lodash to filter and group before returning a data as part of loadAllData

_.groupBy build dictionary maps


Render a choropleth map of the US
---------------------------------

cloropleth map shows different regions of the map with different colors
color the median of household income with different shades of blue
- the darker the blue, the higher the difference

1 prep the app
- import CountyMap from component/CountyMap which doesn't exist yet
- add countyValue method to App
d3.median(salaries, (d) => d.base_salary)
- will tell us the median

filteredSalaries 
- add after useEffect
- filters after it loads

zoom = null
- start with null

add svg map

recap
- add an import
- add a helper method or two
- update render
-- prep a list of county values
-- remove the "data loaded" indicator
-- render a map


Step 1.1 simplify App state
topoJSON
- geographical data parser to render a map

const [datasets, setDatasets] = useState({
  techSalaries: [],
  medianIncomes: [],
  countyNames: [],
  usTopoJson: null,
  USStateNames: null
})

const { destructure all of the above } = datasets;

async function loadData() {
  const datasets = await loadAllData();
  setDatasets(datasets);
}
- this renders the component once instead of 5 times in a row

Step 3 CountyMap
- create new component CountyMap
- import d3, topojson, lodash

projection = d3.geoAlbersUsa().scale(1280)
- geoAlbersUsa renders USA
- d3 offers many other projections
https://github.com/d3/d3-geo#projections

d3.geoPath().projection(projection)
- path generator that takes geographical data, a projection and returns everything you need to draw a map
- generator takes a projection and returns a function that generates the d attribute of <path> elements
-- general way to specify SVG shapes

d3.scaleQuantize
- splits dataset into chunks based on input
- easy way to have different layers of color
- scaleQuantize is a D3 scale
- this one splits a domain into 9 quantiles and assigns them specific values from the range
-- lets say the domain goes from 0 to 90
-- calling any number btw 0-9 would return 1
-- any number btw 10-19 would return 2
- use to pick colors from an array

GeoJSON is geo data defined with JSON
TopoJSON is a geographical data format based on JSON
- topojson-client library translate geographical datasets into GeoJSON
- TopoJSON produces smaller files
- GeoJSON can be fed directly into D3's geo functions


--- The magic sauce

before we would use static getDerivedStateFromProps to render the projection
- now we use useMemo

projection
- move projection to the center of the map
- scaling it so that it looks ok on the map
- something you experiment with and come up with your own scale as it is different for each use case

if zoom and usTopoJson is available
- zoom into a specific county
- we'll make this available to the users later when we add interaction

centroid
- a function of d3 that lets you center a map on a specific county
- when that happens, we also have to translate the map


-- rendering

calc the mesh from topojson, the part that's being rendered
- mesh renders the areas for the US
- feature renders the lines

use TopoJSON library to grab data out of usTopoJson dataset
- mesh and feature are just what you get back, borders adn flat areas
- mesh
-- calcs a mesh for US States
-- a thin line around the edges
- feature
-- calcs feature for each count
-- fill in with color

// build dictionary that maps county id to value
const countyValueMap = _.fromPairs(values.map((d) => [d.countyID, d.value]));
- optimize by building a map beforehand

return
- loops through list of counties and renders County component
County component
- gets a bunch of attributes and returns a <path>

US state borders
- render a single <path/> element and use geoPath to generate the d attribute


-- step 4 County component